./Unit.c:    if(unit->path.count > 1 && unit->path_index == 0)
./Unit.c:        unit->path_index++;
./Unit.c:    const Point point = (unit->path_index == unit->path.count - 1) ? unit->cart_grid_offset_goal : zero;
./Unit.c:    const Point goal_grid_coords = Grid_GetGridPointWithOffset(grid, unit->path.point[unit->path_index], point);
./Unit.c:    const Point unit_grid_coords = Grid_GetGridPointWithOffset(grid, unit->cart, unit->cart_grid_offset);
./Unit.c:    unit->path_index = 0;
./Unit.c:    unit->path_index_time = 0;
./Unit.c:    unit->path = Points_Free(unit->path);
./Unit.c:    unit->path_index++;
./Unit.c:    unit->path_index_time = 0;
./Unit.c:    if(unit->path_index >= unit->path.count)
./Unit.c:    const Point accel = Point_Normalize(delta, unit->accel);
./Unit.c:    unit->velocity = Point_Add(unit->velocity, accel);
./Unit.c:    if(!unit->is_chasing)
./Unit.c:        const bool enough_alignment_force = Point_Mag(unit->group_alignment) > CONFIG_UNIT_ALIGNMENT_DEADZONE;
./Unit.c:        const Point dir = enough_alignment_force ? unit->group_alignment : accel;
./Unit.c:    unit->path_index_time++;
./Unit.c:    const Point deccel = Point_Normalize(unit->velocity, unit->accel);
./Unit.c:    const Point velocity = Point_Sub(unit->velocity, deccel);
./Unit.c:    const Point dot = Point_Dot(velocity, unit->velocity);
./Unit.c:    unit->velocity = (dot.x >= 0 && dot.y >= 0) ? velocity : zero; // XXX. Double check the math...
./Unit.c:    if(unit->path.count > 0)
./Unit.c:    else if(Point_Mag(unit->velocity) > 0) Decelerate(unit);
./Unit.c:    if(Point_Mag(unit->velocity) > unit->max_speed)
./Unit.c:        unit->velocity = Point_Normalize(unit->velocity, unit->max_speed);
./Unit.c:    unit->cart_grid_offset = Grid_CellToOffset(grid, unit->cell);
./Unit.c:    unit->cart = Grid_CellToCart(grid, unit->cell);
./Unit.c:    unit->cell = unit->cell_last;
./Unit.c:    unit->velocity = zero;
./Unit.c:    unit->cell_last = unit->cell;
./Unit.c:    unit->cell = Point_Add(unit->cell, unit->velocity);
./Unit.c:    if(Point_Mag(unit->velocity) < CONFIG_UNIT_VELOCITY_DEADZONE)
./Unit.c:    const int32_t base = (int32_t) unit->file - (int32_t) unit->state;
./Unit.c:    unit->state = state;
./Unit.c:    unit->file = file;
./Unit.c:        unit->timer = 0;
./Unit.c:    const Animation animation = graphics.animation[unit->color][attack];
./Unit.c:    Util_Log("cart                  :: %d %d\n", unit->cart.x, unit->cart.y);
./Unit.c:    Util_Log("cart_grid_offset      :: %d %d\n", unit->cart_grid_offset.x, unit->cart_grid_offset.y);
./Unit.c:    Util_Log("cart_grid_offset_goal :: %d %d\n", unit->cart_grid_offset_goal.x, unit->cart_grid_offset_goal.y);
./Unit.c:    Util_Log("cell                  :: %d %d\n", unit->cell.x, unit->cell.y);
./Unit.c:    Util_Log("max_speed             :: %d\n",    unit->max_speed);
./Unit.c:    Util_Log("accel                 :: %d\n",    unit->accel);
./Unit.c:    Util_Log("velocity              :: %d %d\n", unit->velocity.x, unit->velocity.y);
./Unit.c:    Util_Log("path_index_time       :: %d\n",    unit->path_index_time);
./Unit.c:    Util_Log("path_index            :: %d\n",    unit->path_index);
./Unit.c:    Util_Log("path.count            :: %d\n",    unit->path.count);
./Unit.c:    Util_Log("selected              :: %d\n",    unit->is_selected);
./Unit.c:    Util_Log("file                  :: %d\n",    unit->file);
./Unit.c:    Util_Log("file_name             :: %s\n",    unit->file_name);
./Unit.c:    Util_Log("id                    :: %d\n",    unit->id);
./Unit.c:    Util_Log("command_group         :: %d\n",    unit->command_group);
./Unit.c:    Util_Log("health                :: %d\n",    unit->health);
./Unit.c:    Util_Log("attack_frames_per_dir :: %d\n",    unit->attack_frames_per_dir);
./Unit.c:    unit->velocity = Point_Add(unit->velocity, unit->stressors);
./Unit.c:    return unit->command_group == other->command_group
./Unit.c:        && unit->color == other->color;
./Unit.c:    if(unit->dir_timer > CONFIG_UNIT_DIRECTION_TIMER_EXPIRE)
./Unit.c:        unit->dir = Direction_CartToIso(Direction_GetCart(dir));
./Unit.c:        unit->dir_timer = 0;
./Unit.c:    if(!State_IsDead(unit->state))
./Unit.c:        unit->cart_grid_offset_goal = cart_grid_offset_goal;
./Unit.c:        unit->path = Points_New(2);
./Unit.c:        unit->path = Points_Append(unit->path, unit->cart);
./Unit.c:        unit->path = Points_Append(unit->path, cart_goal);
./Units.c:    if(!State_IsDead(unit->state))
./Units.c:        unit->cart_grid_offset_goal = cart_grid_offset_goal;
./Units.c:        unit->command_group = units.command_group_next;
./Units.c:        unit->command_group_count = units.select_count;
./Units.c:        unit->path = Field_SearchBreadthFirst(field, unit->cart, cart_goal);
./Units.c:        if(unit->color == COLOR_BLU)
./Units.c:        if(unit->is_selected
./Units.c:        && unit->max_speed > 0)
./Units.c:        Stack* const stack = GetStack(units, unit->cart);
./Units.c:    if(!State_IsDead(unit->state))
./Units.c:        const Stack stack = Units_GetStackCart(units, unit->cart);
./Units.c:        const Point delta = Point_Sub(stack.center_of_mass, unit->cell);
./Units.c:    if(!State_IsDead(other->state) && unit->id != other->id)
./Units.c:        const Point diff = Point_Sub(other->cell, unit->cell);
./Units.c:        const int32_t width = UTIL_MAX(unit->width, other->width);
./Units.c:            return unit->color == other->color
./Units.c:    if(!State_IsDead(unit->state))
./Units.c:            const Point cart = Point_Add(unit->cart, cart_offset);
./Units.c:    if(!State_IsDead(unit->state))
./Units.c:            const Point cart = Point_Add(unit->cart, cart_offset);
./Units.c:                && unit->id != other->id
./Units.c:    if(!State_IsDead(unit->state))
./Units.c:        const Point n_point = Point_Add(unit->cart, n);
./Units.c:        const Point e_point = Point_Add(unit->cart, e);
./Units.c:        const Point s_point = Point_Add(unit->cart, s);
./Units.c:        const Point w_point = Point_Add(unit->cart, w);
./Units.c:        const Point offset = Grid_GetCornerOffset(grid, unit->cart_grid_offset);
./Units.c:        const int32_t repulsion = 10 * unit->accel; // XXX. How strong should this be?
./Units.c:    if(!State_IsDead(unit->state))
./Units.c:        unit->group_alignment = AlignBoids(units, unit);
./Units.c:        const Point cohese = unit->command_group_count > CONFIG_UNIT_COHESION_COUNT ? CoheseBoids(units, unit) : zero;
./Units.c:            unit->group_alignment,
./Units.c:        unit->stressors = Point_Mag(stressors) < CONFIG_UNITS_STRESSOR_DEADZONE ? zero : stressors;
./Units.c:    if(!State_IsDead(unit->state))
./Units.c:        const Stack stack = Units_GetStackCart(units, unit->cart);
./Units.c:        const int32_t max = Stack_GetMaxPathIndex(stack, unit->color, unit->command_group);
./Units.c:    if(!State_IsDead(unit->state))
./Units.c:        const Stack stack = Units_GetStackCart(units, unit->cart);
./Units.c:            && unit->path.count == 0
./Units.c:    if(!State_IsDead(unit->state) && unit->path_index_time > CONFIG_UNIT_PATHING_TIMEOUT_CYCLES)
./Units.c:        const Stack stack = Units_GetStackCart(units, unit->cart);
./Units.c:        if(unit->path.count > 0)
./Units.c:            const Point cart_goal = unit->path.point[unit->path.count - 1];
./Units.c:                if(reference->color == unit->color)
./Units.c:                    FindPath(units, reference, cart_goal, unit->cart_grid_offset_goal, field);
./Units.c:    return unit->attack_frames_per_dir * CONFIG_ANIMATION_DIVISOR;
./Units.c:    if(!State_IsDead(unit->state)
./Units.c:        const Point diff = Point_Sub(other->cell, unit->cell);
./Units.c:            if(unit->timer % last_frame == 0)
./Units.c:                other->health -= unit->attack;
./Units.c:    if(!State_IsDead(unit->state))
./Units.c:            const Point cart = Point_Add(unit->cart, cart_offset);
./Units.c:                if(unit->color != other->color)
./Units.c:        const Point cart = Point_Add(unit->cart, cart_offset);
./Units.c:            if(other->color != unit->color
./Units.c:                const Point diff = Point_Sub(other->cell, unit->cell);
./Units.c:    if(!State_IsDead(unit->state))
./Units.c:            const Point cell_diff = Point_Sub(closest->cell, unit->cell);
./Units.c:            unit->is_chasing = true;
./Units.c:            unit->is_chasing = false;
./Units.c:        if(!State_IsDead(unit->state))
./Units.c:            if(!Units_CanWalk(needle->units, needle->map, unit->cart))
./Units.c:            if(unit->is_selected && !State_IsDead(unit->state))
./Units.c:        unit->timer++;
./Units.c:        unit->dir_timer++;
./Units.c:    return unit->fall_frames_per_dir * CONFIG_ANIMATION_DIVISOR;
./Units.c:        if(unit->state == STATE_FALL
./Units.c:        && unit->timer == last_tick)
./Units.c:            unit->is_selected = false;
./Stack.c:        if(!State_IsDead(unit->state))
./Stack.c:            out = Point_Add(out, unit->cell);
./Stack.c:        if(unit->path_index > max
./Stack.c:        && unit->color == color
./Stack.c:        && unit->command_group == command_group) // XXX. Needs check for unit type too.
./Stack.c:            max = unit->path_index;
